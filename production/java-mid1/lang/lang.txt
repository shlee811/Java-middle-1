<java.lang 패키지 소개>
자바가 기본으로 제공하는 라이브러리(클래스 모음) 중에 가장 기본이 되는 것이 바로 `java.lang` 패키지이다.
여기서 `lang` 은 `Language` (언어)의 줄임말이다. 쉽게 이야기해서 자바 언어를 이루는 가장 기본이 되는 클래스들을
보관하는 패키지를 뜻한다.

**java.lang 패키지의 대표적인 클래스들**
`Object` : 모든 자바 객체의 부모 클래스
`String` : 문자열
`Integer` , `Long` , `Double` : 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것
`Class` : 클래스 메타 정보
`System` : 시스템과 관련된 기본 기능들을 제공


<Object 클래스>
자바에서 모든 클래스의 최상위 부모 클래스는 항상 `Object` 클래스이다.


**묵시적(Implicit) vs 명시적(Explicit)**
묵시적: 개발자가 코드에 직접 기술하지 않아도 시스템 또는 컴파일러에 의해 자동으로 수행되는 것을 의미
명시적: 개발자가 코드에 직접 기술해서 작동하는 것을 의미


<자바에서 Object 클래스가 최상위 부모 클래스인 이유>
모든 클래스가 `Object` 클래스를 상속 받는 이유는 다음과 같다.
-공통 기능 제공
-다형성의 기본 구현


**공통 기능 제공**
객체의 정보를 제공하고, 이 객체가 다른 객체와 같은지 비교하고, 객체가 어떤 클래스로 만들어졌는지 확인하는 기능은
모든 객체에게 필요한 기본 기능이다. 이런 기능을 객체를 만들 때 마다 항상 새로운 메서드를 정의해서 만들어야 한다면 상당히 번거로울 것이다.
그리고 막상 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들어서 일관성이 없을 것이다.
예를 들어서 객체의 정보를 제공하는 기능을 만든다고 하면 어떤 개발자는 `toString()`으로 또 어떤 개발자는 `objectInfo()` 와 같이
서로 다른 이름으로 만들 수 있다.
객체를 비교하는 기능을 만들 때도 어떤 개발자는 `equals()`으로 어떤 개발자는 `same()`으로 서로 다른 이름으로 만들 수 있다

`Object` 는 모든 객체에 필요한 공통 기능을 제공한다. `Object` 는 최상위 부모 클래스이기 때문에 모든 객체는 공통
기능을 편리하게 제공(상속) 받을 수 있다.

`Object` 가 제공하는 기능은 다음과 같다.
-객체의 정보를 제공하는 `toString()`
-객체의 같음을 비교하는 `equals()`
-객체의 클래스 정보를 제공하는 `getClass()`
-기타 여러가지 기능

개발자는 모든 객체가 앞서 설명한 메서드를 지원한다는 것을 알고 있다.따라서 프로그래밍이 단순화되고,일관성을 가진다.
각각의 기능에 대한 자세한 내용은 이후에 하나씩 알아보자.

**다형성의 기본 구현**
부모는 자식을 담을 수 있다. `Object` 는 모든 클래스의 부모 클래스이다. 따라서 모든 객체를 참조할 수 있다.
`Object` 클래스는 다형성을 지원하는 기본적인 메커니즘을 제공한다. 모든 자바 객체는 `Object` 타입으로 처리될 수 있으며,
이는 다양한 타입의 객체를 통합적으로 처리할 수 있게 해준다. 쉽게 이야기해서 `Object` 는 모든 객체를 다 담을 수 있다.
타입이 다른 객체들을 어딘가에 보관해야 한다면 바로 `Object` 에 보관하면 된다.

**Object 다형성**
`Object` 는 모든 클래스의 부모 클래스이다. 따라서 `Object` 는 모든 객체를 참조할 수 있다.


<Object 배열>
이번에는 `Object` 배열을 알아보자.
`Object` 는 모든 타입의 객체를 담을 수 있다. 따라서 `Object[]` 을 만들면 세상의 모든 객체를 담을 수 있는 배열을 만들 수 있다.

Object가 없다면?
만약 `Object` 와 같은 개념이 없다면 어떻게 될까?
`void action(Object obj)` 과 같이 모든 객체를 받을 수 있는 메서드를 만들 수 없다.
`Object[] objects` 처럼 모든 객체를 저장할 수 있는 배열을 만들 수 없다.

물론 `Object` 가 없어도 직접 `MyObject` 와 같은 클래스를 만들고 모든 클래스에서 직접 정의한 `MyObject` 를 상속 받으면 된다.
하지만 하나의 프로젝트를 넘어서 전세계 모든 개발자가 비슷한 클래스를 만들 것이고,
서로 호환되지 않는 수 많은 `XxxObject` 들이 넘쳐날 것이다.

<toString()>
`Object.toString()` 메서드는 객체의 정보를 문자열 형태로 제공한다. 그래서 디버깅과 로깅에 유용하게 사용된다.
이 메서드는 `Object` 클래스에 정의되므로 모든 클래스에서 상속받아 사용할 수 있다.

<toString() 오버라이딩>
`Object.toString()` 메서드가 클래스 정보와 참조값을 제공하지만 이 정보만으로는 객체의 상태를 적절히 나타내
지 못한다. 그래서 보통 `toString()` 을 재정의(오버라이딩)해서 보다 유용한 정보를 제공하는 것이 일반적이다.

**구체적인 것에 의존**
`BadObjectPrinter` 는 구체적인 타입인 `Car` , `Dog` 를 사용한다. 따라서 이후에 출력해야 할 구체적인 클래스가 10개로 늘어나면
구체적인 클래스에 맞추어 메서드도 10개로 계속 늘어나게 된다. 이렇게 `BadObjectPrinter` 클래스가 구체적인 특정 클래스인
`Car` , `Dog` 를 사용하는 것을 `BadObjectPrinter` 는 `Car` , `Dog` 에 의존한다고 표현한다.

다행히도 자바에는 **객체의 정보를 사용할 때**, 다형적 참조 문제를 해결해줄 `Object` 클래스와 메서드 오버라이딩 문제
를 해결해줄 `Object.toString()` 메서드가 있다. (물론 직접 `Object` 와 비슷한 공통의 부모 클래스를 만들어서 해결할 수도 있다.)

추상적인 것에 의존**
우리가 앞서 만든 `ObjectPrinter` 클래스는 `Car` , `Dog` 같은 구체적인 클래스를 사용하는 것이 아니라, 추상적인
`Object` 클래스를 사용한다. 이렇게 `ObjectPrinter` 클래스가 `Object` 클래스를 사용하는 것을
`ObjectPrinter` 클래스가 `Object` 에 클래스에 의존한다고 표현한다.


추상적**: 여기서 말하는 추상적이라는 뜻은 단순히 추상 클래스나 인터페이스만 뜻하는 것은 아니다. `Animal` 과
`Dog` , `Cat` 의 관계를 떠올려보자. `Animal` 같은 부모 타입으로 올라갈수록 개념은 더 추상적이게 되고, `Dog` ,
`Cat` 과 같이 하위 타입으로 내려갈 수록 개념은 더 구체적이게 된다.

`ObjectPrinter` 의 `print()` 메서드와 전체 구조를 분석해보자.
**다형적 참조**: `print(Object obj)` , `Object` 타입을 매개변수로 사용해서 다형적 참조를 사용한다.
`Car` ,`Dog` 인스턴스를 포함한 세상의 모든 객체 인스턴스를 인수로 받을 수 있다.

**메서드 오버라이딩**: `Object` 는 모든 클래스의 부모이다. 따라서 `Dog` , `Car` 와 같은 구체적인 클래스는
`Object` 가 가지고 있는 `toString()` 메서드를 오버라이딩 할 수 있다. 따라서 `print(Object obj)` 메서
드는 `Dog` , `Car` 와 같은 구체적인 타입에 의존(사용)하지 않고, 추상적인 `Object` 타입에 의존하면서 런타임에
각 인스턴스의 `toString()` 을 호출할 수 있다.

<OCP 원칙**>
기본편에서 학습한 OCP 원칙을 떠올려보자.
**Open**: 새로운 클래스를 추가하고, `toString()` 을 오버라이딩해서 기능을 확장할 수 있다.
**Closed**: 새로운 클래스를 추가해도 `Object` 와 `toString()` 을 사용하는 클라이언트 코드인
            `ObjectPrinter` 는 변경하지 않아도 된다.

다형적 참조, 메서드 오버라이딩, 그리고 클라이언트 코드가 구체적인 `Car` , `Dog` 에 의존하는 것이 아니라 추상적인
`Object` 에 의존하면서 OCP 원칙을 지킬 수 있었다. 덕분에 새로운 클래스를 추가하고 `toString()` 메서드를 새롭
게 오버라이딩해서 기능을 확장할 수 있다. 그리고 이러한 변화에도 불구하고 클라이언트 코드인 `ObjectPrinter` 는
변경할 필요가 없다.

ObjectPrinter` 는 모든 타입의 부모인 `Object` 를 사용하고, `Object` 가 제공하는 `toString()` 메서드만 사용한다.
따라서 `ObjectPrinter` 를 사용하면 세상의 모든 객체의 정보(`toString()` )를 편리하게 출력할 수 있다.

**자바 언어는 객체지향 언어 답게 언어 스스로도 객체지향의 특징을 매우 잘 활용한다.**
우리가 지금까지 배운 `toString()` 메서드와 같이, 자바 언어가 기본으로 제공하는 다양한 메서드들은 개발자가
필요에 따라 오버라이딩해서 사용할 수 있도록 설계되어 있다.

**참고 - 정적 의존관계 vs 동적 의존관계**
정적 의존관계는 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미한다. 앞서 보여준 클래스 의존 관계 그림
이 바로 정적 의존관계이다. 쉽게 이야기해서 프로그램을 실행하지 않고, 클래스 내에서 사용하는 타입들만 보면
쉽게 의존관계를 파악할 수 있다.

동적 의존관계는 프로그램을 실행하는 런타임에 확인할 수 있는 의존관계이다.
앞서 `ObjectPrinter.print(Object obj)` 에 인자로 어떤 객체가 전달 될 지는 프로그램을 실행해봐야 알 수 있다.
어떤 경우에는 `Car` 인스턴스가 넘어오고, 어떤 경우에는 `Dog` 인스턴스가 넘어온다.
이렇게 런타임에 어떤 인스턴스를 사용하는지를 나타내는 것이 동적 의존관계이다.
참고로 단순히 의존관계 또는 어디에 의존한다고 하면 주로 정적 의존관계를 뜻한다.

예) `ObjectPrinter` 는 `Object` 에 의존한다.


정리
<Object의 나머지 메서드>
`clone()`=>객체를 복사할 때 사용한다. 잘 사용하지 않으므로 다루지 않는다.
`hashCode()`=> `equals()` 와 `hashCode()` 는 종종 함께 사용된다. `hashCode()` 는 뒤에 컬렉션 프레임워크에서 자세히 설명한다.
`getClass()` => 뒤에 `Class` 에서 설명한다.
`notify()` , `notifyAll()` , `wait()` 멀티쓰레드용 메서드이다. 멀티쓰레드에서 다룬다.

